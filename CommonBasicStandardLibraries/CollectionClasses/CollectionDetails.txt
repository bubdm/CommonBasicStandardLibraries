Thinking about adding new collection classes.

Code here
https://github.com/Microsoft/referencesource/blob/master/System/compmod/system/collections/objectmodel/observablecollection.cs
and
https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Collections/ObjectModel/Collection.cs

based on that, will attempt to create 2 custom list classes.

one will be for when we know we don't need notifications.
and another one when we know the ui needs to know about changes.

one can't inherit from another.

however, would like extensions that use any of the 2.

for that to work, we need to know what things they both have in common

then implement the interfaces.

then what would happen is when sending data, you will for sure be working with one of the 2 types.

also needs extensions for to what we need.


think about how far to go with it.

has to decide on whether to do extensions or just more methods for the custom classes.
depending on how common.

the most common has to be built in.

the ones not so common can be extensions.

extensions also needs to sometimes actually modify a list as well.


for the list, 2 choices:
choice 1:
inherit from list

choice 2:
from scratch.

i did notice a toarray a lot.
hopefully i am not forced to implement that.

needs to see what the minimum that needs to be implemented for this to work.


IList (iffy).
if doing custom, maybe don't even need the IList
this will mean i will use new for everything so code will look for the new interface.

however, needs to work with linq.

probably means at least needs ienumerable.
otherwise, linq won't work.
not quite comfortable enough to create my own linq
besides has no options for sql like commands though.


if collection, needs INotifyCollectionChange and INotifyPropertyChanged (not too bad).


also IList (not sure) inherits from ICollection which is from IEnumerable
and IReadOnlyList


i propose the custom one will be from IList (well see)
whatever it is needs to be in common with list

will risk not using ICollection since that requires CopyToArray
would prefer to not have to copy into array but instead copy to another custom list again.
the only catch is the interface is not going to know which type it will copy to.
or maybe i won't even have the CopyToArray.

could instead copy to another of the interface one.
however, since i have 2 implementations, then i can use logic to decide what to do.

ienumerable is for sure necessary.
there are lots of samples on how to do that though.

if i don't implement from the ICollection or IList, then I will need to instead make a copy of the list(of
object and then add the other stuff i want.

list implements
IList

IList is in common but some things are missing that are needed.

i hope i am not forced to inherit from List.
If so, then i have to have at least the ones from IList plus others.

good news is for the extensions, i can use logic to decide which new interface one to create between the list or the collection.
if i have neither, then will raise exception since i will only support 2 type of lists and both are custom.

the challenge is they had the throwhelper.   unless i find out what that is about, then i have to just raise standard exceptions.

if i cannot find the throwhelper, then i will be forced to attempt to use the built in throw the type of exception needed and hopefully it will work properly.
this also means that there are cases when i should throw a specific type to exception.


hopefully i can find the source code for the dictionary since i may research that.

link is here

https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Collections/Generic/Dictionary.cs


list is here
https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Collections/Generic/List.cs 



looks like its best to base on hidden stuff.

as far as player cards, if i want the easier stuff, since i already know what types will be used, will do the deck for the key everytime.

however, i will have custom ways of getting specifc cards.

for this part, looks like what will happen is i will use the normal indexers.

because behind the scenes it will be dictionary, it means that its guaranteed you can't add a card that alway exists.

lots will change with the dictionary.


2 choices.
either 2 versions which one notifies and one does not.
or will be the notify and if you have nothing, just ignore.

since i will have interfaces, can still work properly.



its possible that i may be forced to create some of the game classes in the big class after all.
because i have extensions and if one returns a list, then how would it know what list to create.

its looking more like if i want a stack that is limited, i have to create my own and wrap around the list (of ) object.

refer to the list example to see how to implement what needs to be implemented.


one suggestion.

a base list class (hidden list of)

well see about whether it needs to be marked serializable.

i think would be best if i used interfaces.

find out what is in common and implement them.



Here is one that could help with my idea:
https://github.com/GeoffCox/Public/blob/master/ObservableHashSet/ObservableHashSetOfT.cs 


looks like one possibility is to add to both hash and list.

if i do this way, then if i need index, will use the underlying list
however, if i need to search for card, will  use the hash.

the advantage of doing it that way is i can have fast lookups by 2 methods.
either by card or by index.
both are needed sometimes.

this means i have to controll access to it.

one will be remove card (deck)
so if you send a deck, it will remove

i think that removing card cannot be index based.
this is good for doing card collections.



its looksing like i can't do hashsets after all.
because i see no way of being able to get to the specific item needed easily.

this means for the cardlist,  i will have to use both dictionary and list.
so both lists and the deck are supported.

this means that list can use generics.
however, it has to be at least the type of interface card.
so deck can be used.

if there are basic things i know that all cards need, it can be it.   i would propose having no implemention so we don't have to know what interface to use.

2 choices.
1.  either a separate library for the new collections
2.  put as one.

on the other hand, if interfaces are used, may be no problem.
yet if i have to create a new of the list, could cause a problem.
since i don't know about the new special class though.

yet i could send in an abstract factory so a factory would have to be used.
it is static though and want to keep as static since its used with extensions.

i really don't want to have to use factories everywhere here too though.

step 1 is the interfaces.

it was a hard decision about whether the random should be interfaces or part of the lists.

the only problem is if getting random lists, it can't do the notify.  since i have control and they said the paterns was not absolute, then i think each of them needs to do the random functions.

random is going to be the hardest.
i probably can't go wrong with making all implement the interface.

because i can decide later whether there is lots of shared code or not.'


this means if you get something back of the custom type, then it can be randomized.




looks like i have a pretty good idea of what is needed now for the custom list.

everything i want to make this custom list must implement the things i specified.

so no matter what structure i use (inheritance or not, will still work)

if there is anything in common, then will start attaching behaviors.

for those, i will have to obviously give it the information needed so it can do its job.

the good thing about interfaces is its open to change.

if i later find i have to add other behaviors, i can always put some from one interface to another.


starting february 16, 2019, will go ahead and attempt to build an abstract class.

if that works, then that would be great.  however, no guarantees.

if the abstract class does not work so well, then this means that may need behaviors attached.

it also depends if there is enough of a pattern.

maybe it can send an interface and work off it.
again, no guarantees


classes to create:
1.  attempted abstract class (well see)
2.  basic list (for all basic stuff)
3.  observable list
this is for purposes where it needs to be observable.

i may later do a game card basic and a game card observable.

this is where i may need to attach behaviors since we can't do multiinheritance.

i could be forced to have 2 different behaviors (well see)

could need other stuff as well (?)

looks like i will need to attach modify behaviors.
i probably don't need for random or sorting.
since those 2 are done to a list.
also decided to have no abstract class
however, can delegate some responsibilities or at least made virtual to the derived classes.
for cases where inheritance would have duplicate behavior, then will attach behaviors.


looks like what we have left is the following:
1.  the part the require conditions (done)  turned out to not be too difficult

the hardest part is the random functions.

todo:
1.  shufflelist (when only a certain number)
2.  shufflelist (all)
3.  getrandomitem
4.  getrandomlist

probably should do getrandomitem first since that should be easiest.


todo:
1.  shufflelist (done)
2.  shufflelist (all)
3.  RemoveAllAndObtain (done)


the next step is the testing of the lists.
i can either do that or continue with what i was working on for the changes.

